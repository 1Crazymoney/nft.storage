type Block {
  """
  The hash of the block
  """
  hash: ID! @unique

  """
  The block number
  """
  number: Long! @unique

  tokens: [Token!] @relation
}

type Token {
  id: String! @unique

  tokenID: String!
  mintTime: String!
  """
  Present when ERC721Metadata interface is implemented.
  """
  tokenAsset: TokenAsset

  contract: TokenContract! @relation
  owner: Owner! @relation
  blocks: [Block!] @relation

  imported: [ERC721ImportResult!] @relation
}

"""
TokenAsset represents contents of the tokenURI which may not have been found /
pinned yet. It may have been added by the chain scraper, when token with this
`tokenURI` was discovered. Alternatively it could have been created by an
upload to nft.storage, in which case it may not have any refferers but it would
have uploads.
"""
type TokenAsset {
  """
  Tokens that have this `tokenURI`. This relation allows us to identify all
  tokens that have a same `tokenURI`.
  """
  referrers: [Token!] @relation

  """
  NFT Dags that encapsulate this token metadata. This will appear on instances
  that were create through a `client.store()` API.
  """
  ipnft: [IPNFT!] @relation

  """
  URI that was discovered either in the eth chain or generated by `client.store`
  client API.
  """
  tokenURI: String! @unique

  """
  When `tokenURI` points to JSON file that conforms to the ERC721 Metadata JSON
  Schema it is fetched parsed and stored as related Metadata document.
  """
  metadata: Metadata @relation

  """
  Problem description if failed to get the metadata.
  """
  problem: String

  # Note: Can not make this required field as we already have ton of records
  # that do not contain this field
  created: Time

  updated: Time
}

type Metadata {
  source: TokenAsset! @relation @unique

  """
  Content corresponding to the metadata.
  """
  content: Content! @relation

  """
  Identifies the asset this token represents
  """
  name: String!

  """
  Describes the asset this token represents
  """
  description: String!

  """
  A file representing the asset this token represents
  """
  image: Resource! @relation

  """
  Additional assets that token linked to
  """
  assets: [Resource!] @relation
}

enum ResourceStatus {
  """
  Resource was queued to be processed.
  """
  Queued

  """
  URI is either malformed or the protocol is not supported.
  """
  URIParseFailed

  """
  Was unable to fetch the content.
  """
  ContentFetchFailed

  """
  Corresponding content was linked.
  """
  ContentLinked
}

type Resource {
  referrers: [Metadata!] @relation
  directoryUploads: [DirectoryUpload!] @relation

  status: ResourceStatus! @index
  created: Time!
  updated: Time!

  """
  URI with which resource was identified.
  """
  uri: String! @unique @index

  """
  ipfs:// url if `uri` was referring to gateway URL.
  """
  ipfsURL: String @index

  content: Content! @index

  contentType: String

  """
  Problem description if there was problem in pinning a resource.
  """
  problem: String
}

"""
Details of the root of a file/directory stored on web3.storage.
"""
type Content {
  """
  Backlinks to all the resources that link to this content.
  """
  resources: [Resource!] @relation
  """
  Backlinks to blob uploads that have provided this content.
  """
  blobUploads: [BlobUpload!] @relation
  """
  Blacklings to all directory uploads that have provided this content.
  """
  directoryUploads: [DirectoryUpload!] @relation
  """
  Car uploads that have provided this content.
  """
  carUploads: [CarUpload!] @relation

  """
  Backlinks to remote pinning service requests that pinned this content
  """
  remotePinningServiceUpload: [RemotePinningServiceUpload!] @relation

  ipnfts: [IPNFT!] @relation

  """
  Root CID for this content.
  """
  cid: String! @unique

  """
  IPFS nodes pinning this content.
  """
  pins: [Pin]! @relation

  """
  Filecoin deals referencing this content.
  """
  deals: [Deal!]! @relation

  """
  Size of the DAG in bytes. Set if known on upload or for partials is set when
  content is fully pinned in at least one location.
  """
  dagSize: Int

  """
  Creation date.
  """
  created: Time!
}

"""
Information for piece of content pinned in IPFS.
"""
type Pin {
  """
  The content being pinned.
  """
  content: Content! @relation
  """
  Identifier for the service that is pinning this pin.
  """
  location: PinLocation! @relation
  """
  Pinning status at this location.
  """
  status: PinStatus!
  """
  Last time the status was updated.
  """
  updated: Time!
}

"""
Location of a pin.
"""
type PinLocation {
  """
  Known pins at this location.
  """
  pins: [Pin]! @relation

  """
  Libp2p peer ID of the node pinning this pin.
  """
  peerId: String! @unique

  """
  Name of the peer pinning this pin.
  """
  peerName: String

  """
  Geographic region this node resides in.
  """
  region: String
}

type Owner {
  id: ID! @unique
}

type TokenContract {
  id: ID! @unique
  """
  A descriptive name for a collection of NFTs in this contract
  """
  name: String
  """
  An abbreviated name for NFTs in this contract
  """
  symbol: String

  supportsEIP721Metadata: Boolean!

  tokens: [Token!] @relation
}

input ERC721MetadataQuery {
  name: String
  symbol: String
  tokenURI: String
  ipnft: String
}

input MetadaQuery {
  name: String
  description: String
  image: ResourceQuery
}

input ResourceQuery {
  uri: String
  cid: String
}

type Cursor {
  id: String!
}

type ERC721ImportResult {
  """
  Cursor from which import started.
  """
  id: String!
  """
  New cursor after this import.
  """
  nextID: String!
  """
  Tokens that were imported.
  """
  tokens: [Token!]! @relation
}

input ERC721ImportInput {
  """
  Cursor from which import started. If current cursor changed import will be
  rejected.
  """
  id: String!
  """
  Tokens to be imported.
  """
  tokens: [ERC721ImportTokenInput!]!
}

input ERC721ImportTokenInput {
  id: ID!
  tokenID: String!
  tokenURI: String!
  mintTime: String!

  blockHash: String!
  blockNumber: String!

  contract: ERC721ImportTokenContractInput!
  owner: ERC721ImportTokenOwnerInput!
}

input ERC721ImportTokenContractInput {
  id: ID!
  name: String
  symbol: String
  supportsEIP721Metadata: Boolean!
}

input ERC721ImportTokenOwnerInput {
  id: ID!
}

enum TokenAssetStatus {
  Queued
  Failed
  Succeeded
}

input FindTokenAssetsInput {
  status: TokenAssetStatus
}

input FindResourceInput {
  status: ResourceStatus
}

type Query {
  cursor: Cursor! @resolver
  tokens(tokenID: String, mintTime: String): [Token]!
  allTokens: [Token!]
  owner(id: ID): Owner
  block(hash: ID, number: Long): Block
  constract(id: ID): TokenContract

  allImports: [ERC721ImportResult!] @relation
  """
  Provides tokens with the
  """
  findTokenAssets(where: FindTokenAssetsInput): [TokenAsset!]!
    @resolver(paginated: true)
    @relation

  findResources(where: FindResourceInput): [Resource!]!
    @resolver(paginated: true)
    @relation
}

input TokenAssetProblemInput {
  """
  ID of the TokenAsset
  """
  tokenAssetID: ID!
  """
  Problem description
  """
  problem: String!
}

input TokenMetadataImportInput {
  tokenAssetID: ID!
  metadata: MetadataInput
}

input MetadataInput {
  """
  CID for the metadata content.
  """
  cid: String!

  """
  Identifies the asset this token represents
  """
  name: String!
  """
  Describes the asset this token represents
  """
  description: String!
  """
  A file representing the asset this token represents
  """
  image: ResourceInput!

  # """
  # Additional assets that token linked to
  # """
  assets: [ResourceInput!]!
}

input ResourceInput {
  uri: String!
  ipfsURL: String
}

input ResourceProblemInput {
  resourceID: ID!
  status: ResourceStatus!
  problem: String!
}

input ResorcePinInput {
  resourceID: ID!
  status: ResourceStatus!
  ipfsURL: String!
  cid: String!
}

type Mutation {
  importERC721(input: ERC721ImportInput!): ERC721ImportResult! @resolver

  """
  Reports problem with a TokenAsset e.g. it was impossible to parse URI
  or was unable to fetch content from URI, or content was not a JSON.

  Call is rejected if status isn't Queued.
  """
  reportTokenAssetProblem(input: TokenAssetProblemInput): TokenAsset! @resolver

  """
  Imports Token Metadata. Will be rejected if corresponding asset status isn't
  Queued. Otherwise updates corresponding TokenAsset transitioning it to
  Succeeded state.
  """
  importTokenMetadata(input: TokenMetadataImportInput): Metadata! @resolver

  reportResourceProblem(input: ResourceProblemInput): Resource! @resolver
  updateResourcePin(input: ResorcePinInput): Resource! @resolver

  importBlob(input: ImportBlobInput): Upload! @resolver
  importDirectory(input: ImportDirectoryInput): Upload! @resolver
  """
  API endpoint that corresponds to `/store` API of nft.storage.
  """
  importIPNFT(input: ImportIPNFTInput): Upload @resolver
}

type BlobUpload {
  """
  User authentication token that was used to upload this content.
  """
  userKey: UserKey! @relation

  """
  Uploaded content.
  """
  content: Content! @relation

  """
  Creation date.
  """
  created: Time!

  """
  Deletion date.
  """
  deleted: Time
}

type DirectoryUpload {
  """
  User authentication token that was used to upload this content.
  """
  userKey: UserKey! @relation

  """
  Content correspnoding to the directory wrapping all the files.
  """
  content: Content! @relation

  """
  Files that this directory encloses.
  """
  files: [Resourc!] @relation

  """
  Creation date.
  """
  created: Time!

  """
  Deletion date.
  """
  deleted: Time
}

type CarUpload {
  """
  User authentication token that was used to upload this content.
  """
  userKey: UserKey! @relation

  """
  Creation date.
  """
  created: Time!

  """
  Deletion date.
  """
  deleted: Time

  """
  User provided name for this upload.
  """
  name: String

  """
  The root of the uploaded content.
  """
  content: Content! @relation
}

type RemotePinningServiceUpload {
  """
  User authentication token that was used to upload this content.
  """
  userKey: UserKey! @relation

  """
  Creation date.
  """
  created: Time!

  """
  Deletion date.
  """
  deleted: Time

  """
  The root of the uploaded content.
  """
  content: Content!
}

type TokenUpload {
  """
  User authentication token that was used to upload this content.
  """
  userKey: UserKey! @relation

  """
  Creation date.
  """
  created: Time!

  """
  Deletion date.
  """
  deleted: Time

  ipnft: IPNFT! @relation
}

type IPNFT {
  content: Content! @relation @unique
  tokenAsset: TokenAsset! @relation

  created: Time!
}

"""
Filecoin deal for a pin.
"""
type Deal {
  """
  CIDs in this deal.
  """
  contents: [Content!]! @relation @index
  """
  ID of miner this deal was made with.
  """
  miner: String
  """
  Filecoin network deal is made on.
  """
  network: String
  """
  Piece CID.
  """
  pieceCid: String
  """
  CID of the root of the batch data.
  """
  batchRootCid: String
  """
  Identifier for the deal stored on chain.
  """
  chainDealId: Int @unique
  """
  Selector for extracting stored data from the batch root.
  """
  dataModelSelector: String
  """
  Time when deal will be active.
  """
  activation: Time
  """
  Time when deal has expired and will renew.
  """
  renewal: Time
  """
  Current deal status.
  """
  status: DealStatus!
  """
  Human readable reason for the current status.
  """
  statusReason: String
  """
  Last time this deal was updated.
  """
  updated: Time!
}

enum DealStatus {
  Queued
  Proposing
  Accepted
  Failed
  Published
  Active
  Terminated
}

"""
Information for piece of content pinned in IPFS.
"""
type Pin {
  """
  The content being pinned.
  """
  content: Content! @relation
  """
  Identifier for the service that is pinning this pin.
  """
  location: PinLocation! @relation
  """
  Pinning status at this location.
  """
  status: PinStatus!
  """
  Last time the status was updated.
  """
  updated: Time!
}

"""
Location of a pin.
"""
type PinLocation {
  """
  Known pins at this location.
  """
  pins: [Pin]! @relation
  """
  Libp2p peer ID of the node pinning this pin.
  """
  peerId: String! @unique
  """
  Name of the peer pinning this pin.
  """
  peerName: String
  """
  Geographic region this node resides in.
  """
  region: String
}

enum PinStatus {
  Undefined
  ClusterError
  PinError
  UnpinError
  Pinned
  Pinning
  Unpinned
  Remote
  PinQueued
  UnpinQueued
  Sharded
}

input UserInput {
  email: String!
}

input ImportDirectoryInput {
  cid: String!
  created: Time!
  auth: UserAuthInput!
  dagSize: Int!
  files: [ImportDirectoryFileInput!]!
}

input ImportDirectoryFileInput {
  name: String!
  contentType: String!
  cid: String!
}

# TODO: pin status should be written by CRON job.

input ImportBlobInput {
  cid: String!
  contentType: String!
  created: Time!
  auth: UserAuthInput!
  dagSize: Int!
}

input ImportCarInput {
  cid: String!
  created: Time!
  auth: UserAuthInput!
  dagSize: Int!
}

input ImportIPNFTInput {
  metadata: MetadataInput!
  """
  CID of the dag node encapsulating  NFT metadata and it's assets.
  """
  ipnft: String!
  """
  URI to the metadata.json. If omitted defaults to
  `ipfs://${ipnft}/metadata.json`
  """
  tokenURI: String

  """
  Timestamp of when upload happened.
  """
  created: Time!

  # We have it in kv, I'm not sure why but we retain it here.
  dagSize: Int!

  """
  Used to find a corresponding user and associate an upload with it.
  """
  auth: UserAuthInput!

  # TODO:
  # 1. Do we need to include deals here ? I think no.
  # 2. Do we want to include pin here ? I don't think so.
}

"""
Represents users key.
"""
input UserAuthInput {
  secret: String!
}

# # From https://github.com/ipfs-shipyard/nft.storage/blob/c7e5130022ac1d0db13269582bdfa5e60d41bdea/packages/api/src/bindings.d.ts#L82-L92
type User {
  name: String!
  picture: String

  email: String! @unique
  issuer: String! @unique

  """
  Cryptographic public address of the Magic User.
  """
  publicAddress: String!

  """
  GitHub user handle, may be null if user logged in via email.
  """
  github: String

  """
  User authentification keys.
  """
  keys: [UserKey!]! @relation

  """
  Creation date.
  """
  created: Time!
}

"""
API authentication tokens.
"""
type UserKey {
  # """
  # User assigned name.
  # """
  # name: String!

  """
  Secret that corresponds to this key.
  """
  secret: String! @index

  """
  Uploads made using this user key.
  """
  uploads: [Upload!]! @relation @index

  """
  User this key belongs to.
  """
  user: User! @relation @index

  """
  Creation date.
  """
  created: Time!

  """
  Deletion date.
  """
  deleted: Time
}
