// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

generator dbml {
   provider = "prisma-dbml-generator"
}

//Enums
enum resource_status {
    Idle            // Idle: Has not been processed
    PinQueued       // PinQueued: Pin request started.
    // A CID was found in the token_uri because it was a gateway URL.
    // Started a pin yet unknown if content fetch is possible.
    Pinned          //Pinned: Was pinned successfully
    FailedURIParse  //FailedURIParse: Unable to fetch the content
    FailedFetch     //FailedFetch: Unable to fetch content
    PinFailure      //PinFailure:  when pinned by CID but correspoding content isn't online
}

enum token_asset_status {
  Queued
  Failed
  Succeeded
}

enum pin_status {
  PinFailed          // An error occurred pinning.
  Pinned             // Node has pinned the content.
  Pinning            // Node is currently pinning the content.
  PinQueued          // The item has been queued for pinning.
}


//Models
model block {
    hash                String          @id @unique //the hash of the block
    number              Int             @unique     //the block number
    tokens              tokens_on_blocks[]
}

model token {
    id                  String          @id @unique
    token_id            String
    mint_time           DateTime
    token_asset_id      String
    // Present when ERC721metadata interface is implemented.
    token_asset         token_asset      @relation(fields: [token_asset_id], references: [id])
    blocks              tokens_on_blocks[]
    token_contract_id   String
    contract            token_contract   @relation(fields: [token_contract_id], references: [id])
    owner_id            String
    imported            erc721_import_result_to_token[]
}

model tokens_on_blocks {
    block               block           @relation(fields: [block_hash], references: [hash])
    block_hash          String          //scalar for above relation
    token               token           @relation(fields: [token_id], references: [id])
    token_id            String          //scalar for above relation
    created             DateTime        @default(now())
    @@id([block_hash, token_id])
}

model token_asset {
    id                  String          @id @unique
    //Multiple tokens may have the same token_uri. This allows tracking which tokens share same token_uri.
    referrers           token[]
    token_uri           String          @unique
    ipnft               String
    problem             String?         @db.Text()
    // token_uri may point to JSON that contorms to ERC721.
    // this is fetched, parsed and stored as a related metadata document.
    metadata            metadata?
}

model metadata {
    id                  String          @id @unique
    cid                 String?
    source_id           String          @unique
    source              token_asset     @relation(fields: [source_id], references: [id])
    name                String?                      //identifies the asset this token represents
    description         String?         @db.Text()   //describes the asset this token represents
    imageId             String
    image_uri           String          @db.Text()
    assets              resources_on_metadata[]
}

model resource {
    // Jesse Note: This might be not-correct, need to review this relationship
    // I am assuming a resource can (possible appear in multiple metadata Images)
    // confirm with Gozala, fit not metadata? is also doable.
    referrers           resources_on_metadata[]
    status              resource_status
    status_text         String
    created             DateTime        @default(now())
    updated             DateTime        @default(now())
    uri                 String          @id @unique //uri with which resource identified
    ipfs_url            String          @unique     //ipfs:// url if `uri` was referring to gateway URL.

    problem             String          @db.Text()  //Problem description if there was a problem pinning
//   Content referrerced by this resource. When `ipfsURL` is derived content
//   archiving job will simply pin content by that URL and update resource linking
//   resource to it. If however `ipfsURL` could not be derived archiving job will
//   attempt to fetch the content from `uri` and pin it again linkking resource
//   to it.

//   Content field is only going to be present when resource has a `ContentLinked`
    cid                 String?           //CID corresponding to this resource once it is pinned.
    content             content?         @relation(fields: [cid], references: [cid])

}

//Explicit Join table for metadata and resources.
model resources_on_metadata {
    metadata            metadata        @relation(fields: [metadata_id], references: [id])
    metadata_id         String          //scalar for above relation
    resource            resource        @relation(fields: [resource_uri], references: [uri])
    resource_uri        String          //scalar for above relation
    created             DateTime        @default(now())
    @@id([metadata_id, resource_uri])
}


model content {
    cid                 String          @id @unique
    resources           resource[]
    dag_size            Int?
    created             DateTime        @default(now())
    pins                pin[]
}

model pin {
    id                  String          @id @unique     // there wasn't an id so I added this.
    cid                 String
    content             content         @relation(fields: [cid], references: [cid]) //content being pinned
    location_id         String
    location            pin_location    @relation(fields: [location_id], references: [id]) //ref to a pin location pinning this
    pin                 pin_status                      // pinning status at this location
    status_text         String?         @db.Text()      // human readable description of pin status (needed in edge cases)
    updated             DateTime        @default(now())
    created             DateTime        @default(now())
}

model pin_location {
    id                  String          @id @unique
    pins                pin[]                           // Known pins at this location
    peer_id             String                          // Libp2p peer id of the node pinning this pin
    peer_name           String                          // Name of the peer pinning this pin
    region              String                          // Geo region this node resided in
}

model token_contract {
    id                       String     @id @unique
    name                     String                      // descriptive name for a collection of NFTs
    symbol                   String                      // abbreviate name for NFTs
    supports_eip721_metadata Boolean
    tokens                   token[]
}

model erc721_import_result {
    id                 String          @id @unique // import start cursor
    next_id            String                      // new cursor after this import
    tokens             erc721_import_result_to_token[]                     // tokens that were imported
}

//Join import respults to tokens (Many to Many)
model erc721_import_result_to_token {
    erc721_import_result               erc721_import_result           @relation(fields: [erc721_import_result_id], references: [id])
    erc721_import_result_id            String                         //scalar for above relation
    token                              token                          @relation(fields: [token_id], references: [id])
    token_id                           String                         //scalar for above relation
    created                            DateTime                       @default(now())
    @@id([erc721_import_result_id, token_id])
}