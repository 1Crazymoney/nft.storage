// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

generator dbml {
   provider = "prisma-dbml-generator"
}

//Enums
enum resource_status {
    Idle                // Idle: Has not been processed
    PinQueued           // PinQueued: Pin request started.
    // A CID was found in the token_uri because it was a gateway URL.
    // Started a pin yet unknown if content fetch is possible.
    Pinned              //Pinned: Was pinned successfully
    FailedURIParse      //FailedURIParse: Unable to fetch the content
    FailedFetch         //FailedFetch: Unable to fetch content
    PinFailure          //PinFailure:  when pinned by CID but correspoding content isn't online
}

enum nft_asset_status {
  Queued                //Token asset was queued (for the analyzer to process).
  URIParseFailed        //  tokenURI is either malformed or the protocol is not supported.
  ContentFetchFailed    //  Was unable to fetch the content.
  ContentParseFailed    //  Parsing ERC721 metadata failed.
  PinRequestFailed      //  Failed to create a metadata pin request.
  Linked                // Metadata was parsed and all the resources were linked.
}

enum pin_status {
    ClusterError

    PinError
    PinQueued
    Pinned
    Pinning

    Remote
    Sharded

    Undefined
    UnpinError
    UnpinQueued
    Unpinned
    Unpinning
}

enum pin_service {
    Pinata
    IpfsCluster
}

//Models
model block {
    hash                String          @id @unique //the hash of the block
    number              Int             @unique     //the block number
    nfts                nfts_on_blocks[]
}

model nft {
    id                  String          @id @unique
    token_id            String
    mint_time           DateTime
    nft_asset_id        String
    // Present when ERC721metadata interface is implemented.
    nft_asset         nft_asset       @relation(fields: [nft_asset_id], references: [token_uri])
    blocks              nfts_on_blocks[]
    contract_id         String
    contract            contract        @relation(fields: [contract_id], references: [id])
    owner_id            String
    imported            erc721_import_to_nft[]
}

model nfts_on_blocks {
    block               block           @relation(fields: [block_hash], references: [hash])
    block_hash          String          //scalar for above relation
    token               nft             @relation(fields: [nft_id], references: [id])
    nft_id              String          //scalar for above relation
    inserted_at         DateTime        @default(now())
    @@id([block_hash, nft_id])
}

model nft_asset {
    //Multiple tokens may have the same token_uri. This allows tracking which tokens share same token_uri.
    referrers           nft[]
    token_uri           String          @id @unique
    ipnft               String
    problem             String?         @db.Text()
    // token_uri may point to JSON that contorms to ERC721.
    // this is fetched, parsed and stored as a related metadata document.
    metadata            metadata?
}

model metadata {
    id                  String          @id @unique
    content_id          String?
    token_uri           String          @unique
    nft_asset           nft_asset       @relation(fields: [token_uri], references: [token_uri])
    name                String?                      //identifies the asset this token represents
    description         String?         @db.Text()   //describes the asset this token represents
    imageId             String
    image_uri           String          @db.Text()
    assets              resources_on_metadata[]
}

model resource {
    // Jesse Note: This might be not-correct, need to review this relationship
    // I am assuming a resource can (possible appear in multiple metadata Images)
    // confirm with Gozala, fit not metadata? is also doable.
    referrers           resources_on_metadata[]
    status              resource_status
    status_text         String

    uri                 String          @id @unique //uri with which resource identified
    ipfs_url            String          @unique     //ipfs:// url if `uri` was referring to gateway URL.

    problem             String          @db.Text()  //Problem description if there was a problem pinning
    // Content referrerced by this resource. When `ipfsURL` is derived content
    // archiving job will simply pin content by that URL and update resource linking
    // resource to it. If however `ipfsURL` could not be derived archiving job will
    // attempt to fetch the content from `uri` and pin it again linkking resource
    // to it.

    //   Content field is only going to be present when resource has a `ContentLinked`
    cid                 String?         //CID corresponding to this resource once it is pinned.
    content             content?        @relation(fields: [cid], references: [cid])
    inserted_at         DateTime        @default(now())
    updated_at          DateTime        @default(now())
}

//Explicit Join table for metadata and resources.
model resources_on_metadata {
    metadata            metadata        @relation(fields: [metadata_id], references: [id])
    metadata_id         String          // scalar for above relation
    resource            resource        @relation(fields: [resource_uri], references: [uri])
    resource_uri        String          // scalar for above relation
    inserted_at         DateTime        @default(now())
    @@id([metadata_id, resource_uri])
}


model content {
    cid                 String          @id @unique
    resources           resource[]
    dag_size            Int?
    pins                pin[]
    inserted_at         DateTime        @default(now())
}

model pin {
    id                  BigInt          @id @unique @default(autoincrement())
    content_cid         String
    content             content         @relation(fields: [content_cid], references: [cid]) //content being pinned
    service             pin_service
    status              pin_status                      // pinning status at this location
    status_text         String?         @db.Text()      // human readable description of pin status (needed in edge cases)
    updated_at          DateTime        @default(now())
    inserted_at         DateTime        @default(now())
}

model contract {
    id                       String     @id @unique
    name                     String?                      // descriptive name for a collection of NFTs
    symbol                   String?                      // abbreviate name for NFTs
    supports_eip721_metadata Boolean
    nfts                   nft[]
}

model erc721_import {
    id                 String          @id @unique          // import start cursor
    next_id            String                               // new cursor after this import
    tokens             erc721_import_to_nft[]             // tokens that were imported
}

//Join import respults to tokens (Many to Many)
model erc721_import_to_nft {
    erc721_import                      erc721_import                @relation(fields: [erc721_import_id], references: [id])
    erc721_import_id                   String                         //scalar for above relation
    token                              nft                          @relation(fields: [nft_id], references: [id])
    nft_id                             String                         //scalar for above relation
    inserted_at                        DateTime                     @default(now())
    @@id([erc721_import_id, nft_id])
}